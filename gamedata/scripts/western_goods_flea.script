--- Original Author(s) : NLTP_ASHES
--- Edited : N/A
--- Date : 17/04/2023
--- License : Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
---
--- Script used to manage the Mercenary flea market system.

-- ---------------------------------------------------------------------------------------------------------------------
-- Constants, global variables and imported functions
-- ---------------------------------------------------------------------------------------------------------------------

-- Imported functions
local dbg_printf = western_goods_utils.dbg_printf

-- Constants
local ini_sections = ini_file([[plugins\western_goods\flea_market\importer.ltx]])
local offers_per_npc = 5
local offers_exp_freq = 3600000
local min_item_count = 2
local max_item_count = 10
local min_discount = 5
local max_discount = 50

-- Variables
local offers = {}
local current_offer = 1

-- ---------------------------------------------------------------------------------------------------------------------
-- Core Functions
-- ---------------------------------------------------------------------------------------------------------------------

function generate_offers(count)
    local new_offers = {}

    local viable_sections = this.get_viable_sections()

    dbg_printf("[WG] Flea Market | Generating %s offers...", count)

    for i = 1, count do
        local price = 0
        local sections = {}

        for i = 1, math.random(min_item_count,max_item_count) do
            local section = viable_sections[math.random(1,size_table(viable_sections))]
            price = price + ini_sys:r_float_ex(section,"cost", 0)
            table.insert(sections,section)
        end

        local sale = math.random(min_discount,max_discount)
        local cost = math.ceil(price * ((100 - sale) / 100))

        table.insert(new_offers,{ sections=sections, sale=sale, cost=cost })
    end

    dbg_printf("[WG] Flea Market | Generated %s offers :\n%s", count, utils_data.print_table(new_offers, false, true))

    return new_offers
end

function purchase_offer(offer, npc)
    for _,sec in pairs(offer.sections) do
        itms_manager.relocate_item_to_actor(db.actor, npc, sec, 1)
    end
    dialogs.relocate_money(npc, offer.cost, "out")

    dbg_printf("[WG] Flea Market | Purchased offer (qte:%s)(price:%s)(sale:%s)", size_table(offer.sections), offer.cost, offer.sale)

    table.remove(offers[npc:id()].set,current_offer)
end


-- ---------------------------------------------------------------------------------------------------------------------
-- General Dialog Functions
-- ---------------------------------------------------------------------------------------------------------------------

function init_offers(actor, npc)

    dbg_printf("[WG] Flea Market | Initializing for %s(%s)...", npc:id(), npc:section())

    if not offers[npc:id()] then
        offers[npc:id()] = {}
        offers[npc:id()].set = this.generate_offers(offers_per_npc)
        offers[npc:id()].exp = time_global() + offers_exp_freq
    end

    if offers[npc:id()].exp <= time_global() then
        offers[npc:id()].set = this.generate_offers(offers_per_npc)
        offers[npc:id()].exp = time_global() + offers_exp_freq
    end
end

function init_purchase(actor, npc)
    current_offer = 1
end

function exists_current_offer(actor, npc)
    return offers[npc:id()].set[current_offer] ~= nil
end

function can_afford_offer(actor, npc)
    local offer = offers[npc:id()].set[current_offer]
    if offer then
        return db.actor:money() >= offer.cost
    end
    return false
end

function list_offers(actor, npc)
    for _,offer in ipairs(offers[npc:id()].set) do
        local expiration = offers[npc:id()] and offers[npc:id()].exp
        local time_left = expiration and math.floor((expiration - time_global()) / 60000) or "unknown"
        local caption = western_goods_utils.get_translation("st_wg_flea_offer_caption", this.get_expiration_color(time_left), time_left)
        local text = western_goods_utils.get_translation("st_wg_flea_offer_text", this.get_items_text(offer.sections), size_table(offer.sections), this.get_discount_color(offer.sale), offer.sale, offer.cost)

        db.actor:give_talk_message2(caption, text, "ui_inGame2_Osobiy_zakaz", "iconed_answer_item")
    end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Show Current Item Dialog Functions
-- ---------------------------------------------------------------------------------------------------------------------

function st_show_current_item(npc, dialog_id)
    local offer = offers[npc:id()].set[current_offer]
    if offer then
        return western_goods_utils.get_translation("st_wg_flea_offer", offer.sale) .. " " .. western_goods_utils.get_translation("st_wg_flea_offer_end_"..tostring(math.random(0,4)))
    else
        return western_goods_utils.get_translation("st_wg_flea_no_offer")
    end
end

function show_current_offer(npc, actor)
    local offer = offers[npc:id()].set[current_offer]
    if offer then
        local expiration = offers[npc:id()] and offers[npc:id()].exp
        local time_left = expiration and math.floor((expiration - time_global()) / 60000) or "unknown"
        local caption = western_goods_utils.get_translation("st_wg_flea_offer_caption", this.get_expiration_color(time_left), time_left)
        local text = western_goods_utils.get_translation("st_wg_flea_offer_text", this.get_items_text(offer.sections), size_table(offer.sections), this.get_discount_color(offer.sale), offer.sale, offer.cost)

        dbg_printf("[WG] Flea Market | Showing offer (qte:%s)(sale:%s)(price:%s)", size_table(offer.sections), offer.sale, offer.cost)

        db.actor:give_talk_message2(caption, text, "ui_inGame2_Osobiy_zakaz", "iconed_answer_item")
    end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Buy Current Item Dialog Functions
-- ---------------------------------------------------------------------------------------------------------------------

function st_buy_current_item(npc, dialog_id)
    local offer = offers[npc:id()].set[current_offer]
    if offer then
        return western_goods_utils.get_translation("st_wg_flea_offer_buy", offer.cost) .. " " .. western_goods_utils.get_translation("st_wg_flea_offer_buy_end_"..tostring(math.random(0,4)))
    end
end

function buy_current_item(actor, npc)
    this.purchase_offer(offers[npc:id()].set[current_offer], npc)
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Next Item Dialog Functions
-- ---------------------------------------------------------------------------------------------------------------------

function st_next_item(npc, dialog_id)
    local offer = offers[npc:id()].set[current_offer]
    if offer and db.actor:money() >= offer.cost then
        return western_goods_utils.get_translation("st_wg_flea_next_offer")
    else
        return western_goods_utils.get_translation("st_wg_flea_poor_next_offer_"..tostring(math.random(0,2)))
    end
end

function next_item(actor, npc)
    dbg_printf("[WG] Flea Market | Next offer...")
    current_offer = current_offer + 1
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Callbacks registration
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to register callbacks.
--- @return nil
function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Data persistence
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to store information in the save file.
--- @param m_data table
--- @return nil
function save_state(m_data)
    -- Prepare save table
    local offers_save = {}

    -- Make copy of offers table
    copy_table(offers_save, offers)

    -- Pre-process offers table
    for npc_id,data in pairs(offers_save) do
        data.exp = data.exp - time_global()
    end

    -- Save offers table
    m_data.wg_flea_offers = offers_save

    -- Debug prints
    dbg_printf("[WG] Flea Market | Saved offers...\n%s",utils_data.print_table(offers_save, false, true))
end

--- Function used to load information stored in the save file.
--- @param m_data table
--- @return nil
function load_state(m_data)
    -- Retrieve save table
    local offers_save = m_data.wg_flea_offers or {}

    -- Post-process offers table
    for npc_id,data in pairs(offers_save) do
        data.exp = data.exp + time_global()
    end

    -- Restore offers table
    copy_table(offers, offers_save)

    -- Debug prints
    dbg_printf("[WG] Flea Market | Loaded offers...\n%s",utils_data.print_table(offers, false, true))
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Service Functions
-- ---------------------------------------------------------------------------------------------------------------------

function get_viable_sections()
    local viable_sections = {}

    ini_sections:section_for_each(function(section)

        local sec_names = utils_data.collect_section(ini_sections, section, true)

        dbg_printf("[WG] Flea Market | Collecting %s viable sections from '%s'...", size_table(sec_names), section)

        for sec_name,_ in pairs(sec_names) do
            table.insert(viable_sections,sec_name)
        end
    end)

    dbg_printf("[WG] Flea Market | Collected total of %s viable sections", size_table(viable_sections))

    return viable_sections
end

function get_discount_color(percentage)
    if percentage >= 35 then
        return "%c[green]"
    elseif percentage > 15 then
        return "%c[yellow]"
    else
        return "%c[red]"
    end
end

function get_expiration_color(time_left)
    if time_left >= 10 then
        return "%c[default]"
    elseif time_left > 5 then
        return "%c[yellow]"
    else
        return "%c[red]"
    end
end

function get_items_text(sections)
    local items_text = [[\n]]
    for _,sec in pairs(sections) do
        items_text = items_text .. [[ - ]] .. ui_item.get_sec_name(sec) .. [[\n]]
    end
    return items_text
end