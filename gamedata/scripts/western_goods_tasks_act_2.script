---[[
--- Original Author(s) : NLTP_ASHES
--- Edited : N/A
--- Date : 03/03/2023
--- License : Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
---
--- Script used to manage the tasks of the Western Goods addon.
---]]

-- ---------------------------------------------------------------------------------------------------------------------
-- Constants, global variables and imported functions
-- ---------------------------------------------------------------------------------------------------------------------

-- Imported functions
local dbg_printf = western_goods_utils.dbg_printf
local get_translation = game.translate_string
local spawn_squad = western_goods_utils.spawn_squad
local send_dialog = western_goods_dialogs_manager.send_dialog
local se_object_by_sid = western_goods_utils.se_object_by_sid
local game_object_by_sid = western_goods_utils.game_object_by_sid

-- Task variables
TASK_1_CACHE = {}
TASK_2_CACHE = {}
TASK_3_CACHE = {}


-- ---------------------------------------------------------------------------------------------------------------------
-- ACT 2 - CONTRACT WORK
-- ---------------------------------------------------------------------------------------------------------------------
-- TASK 1 - KOLOBOK
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to start Act 2, Task 1.
--- @param first_speaker cse_alife_object
--- @param second_speaker cse_alife_object
--- @return nil
function start_task_1(first_speaker, second_speaker)
	local npc = dialogs.who_is_npc(first_speaker, second_speaker)
	task_manager.get_task_manager():give_task("western_goods_act_2_task_1", npc:id())
	dbg_printf("[WG] Act 2 Task 1 | Task started...")
end

--- Function used to end Act 2, Task 1.
--- @return nil
function end_task_1()
	local kolobok_found = false

	-- Items in player inventory that have a section among the ones in fallback_items
	local secondary_items_found = {}

	-- Iterate player inventory to find if he has kolobok, and gather fallback items in the process
	db.actor:iterate_inventory(function(owner, obj)
		local is_main_item = obj:section() == TASK_1_CACHE.main_item
		local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
		if is_main_item then
			kolobok_found = true
			return
		elseif is_secondary_item then
			table.insert(secondary_items_found, obj)
		end
	end)

	-- If the player doesn't have a Kolobok, use one of the fallback items
	if not kolobok_found then
		for _,obj in pairs(secondary_items_found) do
			itms_manager.use_arty_container(obj)
			break
		end
	end

	task_manager.get_task_manager():set_task_completed("western_goods_act_2_task_1")

	TASK_2_CACHE.available_time = time_global() + 1800000
	dbg_printf("[WG] Act 2 Task 1 | Task completed...")
end

--- Function called when the task is initiated.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_init(actor,npc)
	-- Prepare task cache table
	TASK_1_CACHE.main_item = "af_fuzz_kolobok"
	TASK_1_CACHE.secondary_items = {
		"af_fuzz_kolobok_lead_box",
		"af_fuzz_kolobok_af_aac",
		"af_fuzz_kolobok_af_aam",
		"af_fuzz_kolobok_af_iam"
	}

	-- Spawn task target if it doesn't exist in the world
	local main_item_exists = false

	western_goods_utils.server_objects_iter(function(se_obj)
		if se_obj:section_name() == TASK_1_CACHE.main_item then
			dbg_printf("[WG] Act 2 Task 1 | Main target already exist in the world %s", se_obj.id)
			main_item_exists = true
			return true
		end
	end)

	if not main_item_exists then
		dbg_printf("[WG] Act 2 Task 1 | Main target does not exist in the world...")

		local viable_spawn_anomalies = get_static_chemical_anomalies() or {}
		local spawn_anomaly_id = random_key_table(viable_spawn_anomalies)
		local spawn_anomaly = spawn_anomaly_id and alife_object(spawn_anomaly_id)

		if spawn_anomaly then
			alife_create(TASK_1_CACHE.main_item, spawn_anomaly.position, spawn_anomaly.m_level_vertex_id, spawn_anomaly.m_game_vertex_id)
			dbg_printf("[WG] Act 2 Task 2 | Spawned main target at pos:%s lvid:%s gvid:%s", spawn_anomaly.position, spawn_anomaly.m_level_vertex_id, spawn_anomaly.m_game_vertex_id)
		end
	end

	-- Process info portions
	give_info("western_goods_act_2_task_1_active")
	give_info("western_goods_act_2_task_1_init")
end

--- Function called when the task is successfully completed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_complete(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_1_active")
	disable_info("western_goods_act_2_task_1_init")
	give_info("western_goods_act_2_task_1_finished")

	-- Process quest items
	xr_effects.remove_item(actor, npc, {"af_fuzz_kolobok"})

	-- Process reward
	xr_effects.reward_random_money(actor,npc,{"10000","15000"})
	xr_effects.complete_task_inc_goodwill(actor,npc,{"25","killer"})
end

--- Function called when the task is failed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_fail(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_1_active")
	disable_info("western_goods_act_2_task_1_init")

	-- Process penalty
	xr_effects.fail_task_dec_goodwill(actor,npc,{"35","killer"})
end

--- Function used to retrieve the title of the mission (displayed in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_1_title_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_1_title")
	end
end

--- Function used to retrieve the description of the mission (displayed in the PDA).
--- Warning : naming contract on the translation string : st_wg_trader_act_2_task_1_stage_<stage>_descr.
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_1_descr_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_1_stage_" .. tostring(tsk.stage) .. "_descr")
	end
end

--- Function used to retrieve the target of the mission (marker displayed (or not) in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return number
function task_functor.act_2_task_1_target_f(task_id,field,p,tsk)
	if has_alife_info("western_goods_act_2_task_1_init") then
		if tsk.stage == 0 then
			return nil
		end
		if tsk.stage == 1 then
			return tsk.task_giver_id
		end
	end
end

--- Function used to manage the mission logic as a whole.
--- @param tsk CGameTask
--- @param task_id number
--- @return string
function task_status_functor.act_2_task_1_status_f(tsk,task_id)
	if has_alife_info("western_goods_act_2_task_1_init") then
		-- First stage : Find the artefact
		if tsk.stage == 0 then
			db.actor:iterate_inventory(function(owner, obj)
				local is_main_item = obj:section() == TASK_1_CACHE.main_item
				local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
				if is_main_item or is_secondary_item then
					tsk.stage = 1
					return
				end
			end)
		end

		-- Second stage : Deliver the artefact
		if tsk.stage == 1 then
			local has_item = false

			db.actor:iterate_inventory(function(owner, obj)
				local is_main_item = obj:section() == TASK_1_CACHE.main_item
				local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
				if is_main_item or is_secondary_item then
					has_item = true
					return
				end
			end)

			if not has_item then
				disable_info("western_goods_act_2_task_1_ready_finished")
				tsk.stage = 0
			else
				give_info("western_goods_act_2_task_1_ready_finished")
			end
		end
	end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- TASK 2 - RETRIEVAL MISSION
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to setup the automatic start of Act 2, Task 2.
--- @return nil
function setup_act_2_task_2()
	-- Conditions
	local task_1_done = has_alife_info("western_goods_act_2_task_1_finished")
	local task_2_started = has_alife_info("western_goods_act_2_task_2_active")
	local task_2_done = has_alife_info("western_goods_act_2_task_2_finished")
	local task_opted_in = has_alife_info("western_goods_act_2_task_2_opted_in")
	local task_setup = has_alife_info("western_goods_act_2_task_2_setup")
	local timeout_ready = time_global() > (TASK_2_CACHE.available_time or 0)

	-- If the task is ready to be started
	if task_1_done and not task_2_started and not task_2_done and task_opted_in and not task_setup and timeout_ready then
		CreateTimeEvent("western_goods_setup_task", "act_2_task_2", math.random(600, 1800), function ()
			dbg_printf("[WG] Act 2 Task 2 | Task available...")

			-- Give the task some time after loading the save
			start_task_2(se_object_by_sid("stalker_western_goods_trader"))

			-- Send a message to the player
			dbg_printf("[WG] Act 2 Task 2 | Preparing message from %s", "Anonymous")
			send_dialog({
				{sender="Anonymous", icon="ui_inGame2_no_data", message=game.translate_string("st_wg_act_2_task_2_job_descr")}
			}, true)
			dbg_printf("[WG] Act 2 Task 2 | Message from %s ready", "Anonymous")

			give_info("western_goods_act_2_task_2_setup")

			return true
		end)
	else
		dbg_printf("[WG] What's missing? task_opted_in:%s task_not_setup:%s timeout_ready:%s (%s/%s)", task_opted_in, not task_setup, timeout_ready, time_global(), TASK_2_CACHE.available_time)
	end
end

--- Function used to start Act 2, Task 2.
--- @param task_giver cse_alife_object
--- @return nil
function start_task_2(task_giver)
	task_manager.get_task_manager():give_task("western_goods_act_2_task_2", task_giver.id)
	dbg_printf("[WG] Act 2 Task 2 | Task started...")
end

--- Function used to end Act 2, Task 2.
--- @return nil
function end_task_2()
	task_manager.get_task_manager():set_task_completed("western_goods_act_2_task_2")
	dbg_printf("[WG] Act 2 Task 2 | Task completed...")
end

--- Function called when the task is initiated.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_init(actor,npc)
	TASK_2_CACHE = {
		marked_enemies = {},
		objects = {
			btr 			= { sec="veh_btr",x=-32.9,y=-0.5,z=20.9,lvid=155155,gvid=4971 		},
			sleeping_bag 	= { sec="itm_sleepbag",x=26.6,y=-4.3,z=129.2,lvid=232806,gvid=4970 	}
		},
		squads = {
			army_spawn_data 	= { sec="western_goods_act_2_task_2_army_squad", 	 smart="pri_sim_3" 		},
			mono_spawn_data 	= { sec="western_goods_act_2_task_2_mono_squad", 	 smart="pri_sim_3" 		},
			snork_spawn_data 	= { sec="western_goods_act_2_task_2_snork_squad", 	 smart="pri_b301" 		},
			ecolog_spawn_data 	= { sec="western_goods_act_2_task_2_ecolog_squad", 	 smart="pri_a28_school" },
			zombie_1_spawn_data = { sec="western_goods_act_2_task_2_zombie_1_squad", smart="pri_sim_3" 		},
			zombie_2_spawn_data = { sec="western_goods_act_2_task_2_zombie_2_squad", smart="pri_sim_3" 		},
			bandit_1_spawn_data = { sec="western_goods_act_2_task_2_bandit_1_squad", smart="pri_b301" 		},
			bandit_2_spawn_data = { sec="western_goods_act_2_task_2_bandit_2_squad", smart="pri_a28_school" }
		},
		restrictors = {
			zombie 		= { ax=-97.150344848633,ay=-1.1752129793167,az=-45.473430633545,bx=-81.533813476563,by=5.2640190124512,	bz=-64.902114868164 },
			snork 		= { ax=17.24550819397,	ay=-4.823212146759,	az=129.98883056641,	bx=29.521947860718,	by=-1.0844190120697,bz=121.89762878418 	},
			overlook 	= { ax=27.744569778442,	ay=7.3748621940613,	az=129.99130249023,	bx=53.035232543945,	by=16.793748855591,	bz=121.89153289795 	}
		}
	}

	-- Process info portions
	give_info("western_goods_act_2_task_2_active")
	give_info("western_goods_act_2_task_2_init")
end

--- Function called when the task is successfully completed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_complete(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_2_active")
	disable_info("western_goods_act_2_task_2_init")
	give_info("western_goods_act_2_task_2_finished")
	give_info("western_goods_act_2_finished")

	-- Process reward
	xr_effects.reward_random_money(actor,npc,{"15000","20000"})
	xr_effects.complete_task_inc_goodwill(actor,npc,{"100","killer"})
end

--- Function called when the task is failed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_fail(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_2_active")
	disable_info("western_goods_act_2_task_2_init")

	-- Process penalty
	xr_effects.fail_task_dec_goodwill(actor,npc,{"40","killer"})
end

--- Function used to retrieve the title of the mission (displayed in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_2_title_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_2_title")
	end
end

--- Function used to retrieve the description of the mission (displayed in the PDA).
--- Warning : naming contract on the translation string : st_wg_trader_act_2_task_2_stage_<stage>_descr.
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_2_descr_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_2_stage_" .. tostring(tsk.stage) .. "_descr")
	end
end

--- Function used to retrieve the target of the mission (marker displayed (or not) in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return number
function task_functor.act_2_task_2_target_f(task_id,field,p,tsk)
	if has_alife_info("western_goods_act_2_task_2_init") then
		if tsk.stage == 0 then
			local smart = SIMBOARD:get_smart_by_name("pri_sim_3")
			return smart and smart.id
		end
		if tsk.stage == 1 then
			local zombie_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)
			return zombie_1_squad_se and zombie_1_squad_se.id
		end
		if tsk.stage == 2 then
			local zombie_2_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)
			return zombie_2_squad_se and zombie_2_squad_se.id
		end
		if tsk.stage == 3 then
			-- Put a red marker over all the pursuers (only in pripyat, to avoid cheating)
			if level.name() == "pripyat" then
				mark_current_enemies()
			end

			-- Return nil as to not place an actual task marker
			return nil
		end
		if tsk.stage == 4 then
			-- Remove left-over markers (just in case)
			if level.name() == "pripyat" then
				mark_current_enemies()
			end

			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 5 then
			local snork_squad_se = se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return (snork_squad_se and snork_squad_se.id) or (restrictor and restrictor:id())
		end
		if tsk.stage == 6 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 7 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 8 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 9 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 10 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 11 then
			return tsk.task_giver_id
		end
		if tsk.stage == 12 then
			return tsk.task_giver_id
		end
	end
end

--- Function used to manage the mission logic as a whole.
--- @param tsk CGameTask
--- @param task_id number
--- @return string
function task_status_functor.act_2_task_2_status_f(tsk,task_id)
	if has_alife_info("western_goods_act_2_task_2_init") then
		-- First stage : Get to the Outskirts, somewhere close to the zombies
		if tsk.stage == 0 then
			local zombie_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)

			-- Spawn Zombie squad
			if not TASK_2_CACHE.zombie_1_spawned and not zombie_1_squad_se then
				local spawn_data = TASK_2_CACHE.squads.zombie_1_spawn_data
				zombie_1_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if zombie_1_squad_se then
					TASK_2_CACHE.zombie_1_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			if level.name() ~= "pripyat" then return end

			local dist_to_zombies = zombie_1_squad_se and zombie_1_squad_se.position:distance_to(db.actor:position())
			if dist_to_zombies and dist_to_zombies > 125 then return end

			dbg_printf("[WG] Act 2 Task 2 Stage 0 | Player close to Zombied squad %s", dist_to_zombies)

			tsk.stage = 1
		end

		-- Second stage : Kill the zombies and get close
		if tsk.stage == 1 then
			local zombie_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)

			-- If the zombie squad is dead, and the player is near them
			if not zombie_1_squad_se and western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.zombie) then

				dbg_printf("[WG] Act 2 Task 2 Stage 1 | First Zombied squad is dead")

				local zombie_2_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)

				-- Spawn Zombie squad for next stage
				if not TASK_2_CACHE.zombie_2_spawned and not zombie_2_squad_se then
					local spawn_data = TASK_2_CACHE.squads.zombie_2_spawn_data
					zombie_2_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

					if zombie_2_squad_se then
						TASK_2_CACHE.spawn_throttle = time_global() + 5000
						TASK_2_CACHE.zombie_2_spawned = true
						return
					else
						printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
						return "fail"
					end
				end

				tsk.stage = 2
			end
		end

		-- Third stage : Wait for zombies to die or take part in the fight
		if tsk.stage == 2 then
			local zombie_2_squad_se = se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)
			local army_squad_se = se_object_by_sid(TASK_2_CACHE.squads.army_spawn_data.sec)
			local mono_squad_se = se_object_by_sid(TASK_2_CACHE.squads.mono_spawn_data.sec)

			-- Spawn Army squad
			if TASK_2_CACHE.spawn_throttle < time_global() and not TASK_2_CACHE.army_squad_spawned and not army_squad_se then
				local spawn_data = TASK_2_CACHE.squads.army_spawn_data
				army_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if army_squad_se then
					TASK_2_CACHE.spawn_throttle = time_global() + 5000
					TASK_2_CACHE.army_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- Spawn Army BTR
			if TASK_2_CACHE.spawn_throttle < time_global() and not TASK_2_CACHE.army_btr_spawned then
				local spawn_data = TASK_2_CACHE.objects.btr
				local btr_se = alife_create(spawn_data.sec, vector():set(spawn_data.x, spawn_data.y, spawn_data.z), spawn_data.lvid, spawn_data.gvid)

				if btr_se then
					btr_se.angle = vector():set(0,-1.5708,0)

					logic_enforcer.assign(btr_se.id,'scripts\\tasks\\veh_idle.ltx','logic','ph_car@idle')

					TASK_2_CACHE.spawn_throttle = time_global() + 5000
					TASK_2_CACHE.army_btr_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s x:%s y:%s z:%s lvid:%s gvid:%s",spawn_data.sec, spawn_data.x, spawn_data.y, spawn_data.z, spawn_data.lvid, spawn_data.gvid)
					return "fail"
				end
			end

			-- After 10s, spawn Monolith squad TODO : Decide if Monolith squad should be spawned or not
			if false and TASK_2_CACHE.spawn_throttle < time_global() and not TASK_2_CACHE.mono_squad_spawned and not mono_squad_se then
				local spawn_data = TASK_2_CACHE.squads.mono_spawn_data
				mono_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if mono_squad_se then
					TASK_2_CACHE.mono_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- When zombies are dead, progress task
			if TASK_2_CACHE.zombie_2_spawned and not zombie_2_squad_se then

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Second Zombied squad is dead")

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_stage_2_message_1")}
				})
				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Message from %s ready", "Anonymous")

				if is_player_fighting() then
					dbg_printf("[WG] Act 2 Task 2 Stage 2 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))
					tsk.stage = 3
				else
					dbg_printf("[WG] Act 2 Task 2 Stage 2 | Player is not fighting")
					tsk.stage = 4
				end
			end
		end

		-- Fourth stage : Get to the basement of the school but kill pursuers
		if tsk.stage == 3 then
			if is_player_fighting() then
				local restrictor = db.zone_by_name["pri_surge_hide_b301"]
				local dist_to_basement = restrictor and restrictor:position():distance_to(db.actor:position())

				dbg_printf("[WG] Act 2 Task 2 Stage 3 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))

				if dist_to_basement and dist_to_basement <= 50 and dist_to_basement >= 25 then
					if not TASK_2_CACHE.message_school_pursuers_far_sent then
						send_dialog({
							{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_school_pursuers_far")}
						},true)
						TASK_2_CACHE.message_school_pursuers_far_sent = true
					end
					return
				elseif dist_to_basement and dist_to_basement < 25 then
					send_dialog({
						{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_school_pursuers_close")}
					},true)
					return "fail"
				else
					TASK_2_CACHE.message_school_pursuers_far_sent = false
					return
				end
			else
				dbg_printf("[WG] Act 2 Task 2 Stage 3 | Player is not fighting")
				TASK_2_CACHE.message_school_pursuers_far_sent = false
				tsk.stage = 4
			end
		end

		-- Fifth stage : Get to the basement of the school without being seen
		if tsk.stage == 4 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]

			if not is_player_fighting() then
				local dist_to_basement = restrictor and restrictor:position():distance_to(db.actor:position())
				if dist_to_basement and dist_to_basement < 25 then
					local snork_squad_se = se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)

					-- Spawn snork squad
					if not TASK_2_CACHE.snork_spawned and not snork_squad_se then
						local spawn_data = TASK_2_CACHE.squads.snork_spawn_data
						snork_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

						if snork_squad_se then
							TASK_2_CACHE.snork_spawned = true
							tsk.stage = 5
							return
						else
							printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
							return "fail"
						end
					end
				end
			else
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))
				tsk.stage = 3
			end
		end

		-- Sixth stage : Get to the basement of the school & kill the snorks
		if tsk.stage == 5 then
			local snork_squad_se = se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)

			-- Dialog when player reaches school
			if not TASK_2_CACHE.stage_5_dialog_sent then

				local dialog_sender_1 = { name=alife():actor():character_name(), icon=alife():actor():character_icon()}
				local dialog_sender_2 = { name="Anonymous", icon="ui_inGame2_no_data"}

				dbg_printf("[WG] Act 2 Task 2 Stage 5 | Preparing dialog between %s and %s", dialog_sender_1.name, dialog_sender_2.name)
				send_dialog({
					{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_5_message_1")},
					{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_5_message_2")}
				})
				dbg_printf("[WG] Act 2 Task 2 Stage 5 | Dialog between %s and %s ready", dialog_sender_1.name, dialog_sender_2.name)

				TASK_2_CACHE.stage_5_dialog_sent = true
			end

			-- Spawn sleeping bag
			if not TASK_2_CACHE.sleeping_bag_spawned then
				local spawn_data = TASK_2_CACHE.objects.sleeping_bag
				local sleep_bag_se = alife_create(spawn_data.sec, vector():set(spawn_data.x, spawn_data.y, spawn_data.z), spawn_data.lvid, spawn_data.gvid)

				if sleep_bag_se then
					TASK_2_CACHE.sleeping_bag_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s x:%s y:%s z:%s lvid:%s gvid:%s",spawn_data.sec, spawn_data.x, spawn_data.y, spawn_data.z, spawn_data.lvid, spawn_data.gvid)
					return "fail"
				end
			end

			-- If the zombie squad is dead, and the player is near them
			if TASK_2_CACHE.snork_spawned and not snork_squad_se and western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.snork) then

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Snork squad is dead")

				local bandit_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)

				-- Spawn bandit squad for next stage
				if not TASK_2_CACHE.bandit_1_spawned and not bandit_1_squad_se then
					local spawn_data = TASK_2_CACHE.squads.bandit_1_spawn_data
					bandit_1_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

					if bandit_1_squad_se then
						TASK_2_CACHE.bandit_1_spawned = true
						return
					else
						printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
						return "fail"
					end
				end

				tsk.stage = 6
			end
		end

		-- Seventh stage : Kill the bandits
		if tsk.stage == 6 then
			local bandit_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)

			-- Fail task if player gets out of basement
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.snork) then
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- If bandits are dead, or if they are not enemy with the player
			if TASK_2_CACHE.bandit_1_spawned and not bandit_1_squad_se then

				if not TASK_2_CACHE.stage_6_dialog_sent then

					dbg_printf("[WG] Act 2 Task 2 Stage 6 | First bandit squad is dead")

					local dialog_sender_1 = { name="Anonymous", icon="ui_inGame2_no_data"}
					local dialog_sender_2 = { name=alife():actor():character_name(), icon=alife():actor():character_icon()}

					dbg_printf("[WG] Act 2 Task 2 Stage 6 | Preparing dialog between %s and %s", dialog_sender_1.name, dialog_sender_2.name)
					send_dialog({
						{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_1")},
						{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_2")},
						{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_3")},
						{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_4")}
					})
					dbg_printf("[WG] Act 2 Task 2 Stage 6 | Dialog between %s and %s ready", dialog_sender_1.name, dialog_sender_2.name)

					TASK_2_CACHE.progress_timer = time_global() + 30000
					TASK_2_CACHE.stage_6_dialog_sent = true
				end

				if TASK_2_CACHE.progress_timer < time_global() then
					tsk.stage = 7
				end
			end
		end

		-- Eighth stage : Get to the 3rd floor of the school
		if tsk.stage == 7 then
			-- When the player gets in position, progress task
			if western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				tsk.stage = 8
			end
		end

		-- Ninth stage : Wait for ecologs to arrive
		if tsk.stage == 8 then
			local ecolog_squad_se = se_object_by_sid(TASK_2_CACHE.squads.ecolog_spawn_data.sec)

			-- Spawn Ecolog squad
			if not TASK_2_CACHE.ecolog_spawned and not ecolog_squad_se then
				local spawn_data = TASK_2_CACHE.squads.ecolog_spawn_data
				ecolog_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if ecolog_squad_se then
					TASK_2_CACHE.progress_timer = time_global() + 60000
					TASK_2_CACHE.ecolog_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- If player leaves his position, fail task
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- After 45s, progress task
			if TASK_2_CACHE.progress_timer < time_global() then
				tsk.stage = 9
			end
		end

		-- Tenth stage : Wait for the bandits to die
		if tsk.stage == 9 then
			local bandit_1_squad_se = se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)
			local bandit_2_squad_se = se_object_by_sid(TASK_2_CACHE.squads.bandit_2_spawn_data.sec)

			-- Spawn Bandit squad
			if not TASK_2_CACHE.bandit_2_squad_spawned and not bandit_2_squad_se then
				local spawn_data = TASK_2_CACHE.squads.bandit_2_spawn_data
				bandit_2_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if bandit_2_squad_se then
					TASK_2_CACHE.bandit_2_autokill_timer = time_global() + 40000
					TASK_2_CACHE.bandit_2_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- If player leaves his position, fail task
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				dbg_printf("[WG] Act 2 Task 2 Stage 7 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 7 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- After 20s, start killing the bandits (both bandit_1 and bandit_2 squads) automatically
			if not TASK_2_CACHE.bandit_2_autokilled and TASK_2_CACHE.bandit_2_autokill_timer < time_global() then
				if bandit_1_squad_se then
					for npc in bandit_1_squad_se:squad_members() do
						local npc_obj = db.storage[npc.id] and db.storage[npc.id].object
						if (npc_obj and npc_obj:alive()) then
							western_goods_utils.next_tick(surge_manager.make_dead,npc_obj:id())
						end
					end
				end
				if bandit_2_squad_se then
					for npc in bandit_2_squad_se:squad_members() do
						local npc_obj = db.storage[npc.id] and db.storage[npc.id].object
						if (npc_obj and npc_obj:alive()) then
							western_goods_utils.next_tick(surge_manager.make_dead,npc_obj:id())
						end
					end
				end
				TASK_2_CACHE.progress_timer = time_global() + 20000
				TASK_2_CACHE.bandit_2_autokilled = true
			end

			-- When all bandits are dead, progress task
			if not bandit_1_squad_se and not bandit_2_squad_se and TASK_2_CACHE.progress_timer < time_global() then
				tsk.stage = 10
			end
		end

		-- Eleventh stage : Take cover from the emission
		if tsk.stage == 10 then
			-- Start emission and make ecologs flee
			if not TASK_2_CACHE.surge_started then
				surge_manager.start_surge()

				-- Give info to link script with logic scheme
				give_info("western_goods_act_2_task_2_ecolog_flee")

				TASK_2_CACHE.surge_started = true
			end

			if TASK_2_CACHE.surge_started and surge_manager.is_finished() then
				tsk.stage = 11
			end
		end

		-- Twelfth stage : Task done - for now
		if tsk.stage == 11 then
			local ecolog_squad_se = se_object_by_sid(TASK_2_CACHE.squads.ecolog_spawn_data.sec)

			if ecolog_squad_se then
				alife_release(ecolog_squad_se)
			end

			return "complete"
		end

		-- Thirteenth stage : N/A
		if tsk.stage == 12 then
			return "complete"
		end
	end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Callbacks registration
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to register callbacks.
--- @return nil
function on_game_start()
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("actor_on_first_update", setup_act_2_task_2)

	-- TODO : Test code - to be removed
	-- RegisterScriptCallback("on_key_press",spawn_dunn)
	-- RegisterScriptCallback("on_key_press",spawn_test_squads)
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Data persistence
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to store information in the save file.
--- @param m_data table
--- @return nil
function save_state(m_data)
	-- Prepare save tables
	local TASK_1_SAVE = {}
	local TASK_2_SAVE = {}
	local TASK_3_SAVE = {}

	-- Make copies of task caches
	copy_table(TASK_1_SAVE, TASK_1_CACHE)
	copy_table(TASK_2_SAVE, TASK_2_CACHE)
	copy_table(TASK_3_SAVE, TASK_3_CACHE)

	-- Pre-process tables
	TASK_2_SAVE.available_time = (TASK_2_SAVE.available_time or 0) - time_global()
	TASK_2_SAVE.spawn_throttle = (TASK_2_SAVE.spawn_throttle or 0) - time_global()
	TASK_2_SAVE.progress_timer = (TASK_2_SAVE.progress_timer or 0) - time_global()
	TASK_2_SAVE.bandit_2_autokill_timer = (TASK_2_SAVE.bandit_2_autokill_timer or 0) - time_global()

	-- Debug prints
	dbg_printf("[WG] TASK_2_CACHE.available_time : %s", TASK_2_SAVE.available_time)
	dbg_printf("[WG] TASK_2_CACHE.spawn_throttle : %s", TASK_2_SAVE.spawn_throttle)
	dbg_printf("[WG] TASK_2_CACHE.progress_timer : %s", TASK_2_SAVE.progress_timer)
	dbg_printf("[WG] TASK_2_CACHE.bandit_2_autokill_timer : %s", TASK_2_SAVE.bandit_2_autokill_timer)

	-- Save tables
	m_data.wg_act_2_task_1_cache = TASK_1_SAVE
	m_data.wg_act_2_task_2_cache = TASK_2_SAVE
	m_data.wg_act_2_task_3_cache = TASK_3_SAVE

	dbg_printf("[WG] Saved act 2 task variables")

	-- Save utility function metatables
	m_data.marked_enemies = marked_enemies
end

--- Function used to load information stored in the save file.
--- @param m_data table
--- @return nil
function load_state(m_data)
	-- Retrieve save tables
	local TASK_1_SAVE = m_data.wg_act_2_task_1_cache or {}
	local TASK_2_SAVE = m_data.wg_act_2_task_2_cache or {}
	local TASK_3_SAVE = m_data.wg_act_2_task_3_cache or {}

	-- Post-process tables
	TASK_2_SAVE.available_time = (TASK_2_SAVE.available_time or 0) + time_global()
	TASK_2_SAVE.spawn_throttle = (TASK_2_SAVE.spawn_throttle or 0) + time_global()
	TASK_2_SAVE.progress_timer = (TASK_2_SAVE.progress_timer or 0) + time_global()
	TASK_2_SAVE.bandit_2_autokill_timer = (TASK_2_SAVE.bandit_2_autokill_timer or 0) + time_global()

	-- Debug prints
	dbg_printf("[WG] TASK_2_CACHE.available_time : %s", TASK_2_SAVE.available_time)
	dbg_printf("[WG] TASK_2_CACHE.spawn_throttle : %s", TASK_2_SAVE.spawn_throttle)
	dbg_printf("[WG] TASK_2_CACHE.progress_timer : %s", TASK_2_SAVE.progress_timer)
	dbg_printf("[WG] TASK_2_CACHE.bandit_2_autokill_timer : %s", TASK_2_SAVE.bandit_2_autokill_timer)

	-- Restore task caches
	copy_table(TASK_1_CACHE, TASK_1_SAVE)
	copy_table(TASK_2_CACHE, TASK_2_SAVE)
	copy_table(TASK_3_CACHE, TASK_3_SAVE)

	dbg_printf("[WG] Loaded act 2 task variables")

	-- Load utility function metatables
	marked_enemies = m_data.marked_enemies or {}
end


-- ---------------------------------------------------------------------------------------------------------------------
-- General functions
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to get a table where keys are IDs of chemical anomalies and values are boolean true.
--- @return table
function get_static_chemical_anomalies()

	local viable_anomalies = {}

	-- Set to false all dynamic anomalies
	for _,v in pairs(bind_anomaly_field.dyn_anomalies) do
		for id, _ in pairs(v) do
			viable_anomalies[id] = false
		end
	end

	-- Go through all IDs
	western_goods_utils.server_objects_iter(function(se_obj)
		if IsAnomaly(se_obj) then
			if viable_anomalies[se_obj.id] == nil then
				-- If the ID is unknown, then check for correct type of anomalies
				if string.find(se_obj:section_name(), "chemical") or string.find(se_obj:section_name(), "acidic") then
					viable_anomalies[se_obj.id] = true
				end
			else
				-- If the ID isn't nil, then it's a dynamic anomaly, we set to nil
				viable_anomalies[se_obj.id] = nil
			end
		end
	end)

	dbg_printf("[WG] Number of matching anomalies : %s", size_table(viable_anomalies))

	return viable_anomalies
end

function is_id_from_squad(squad,id)
	if not squad then return end

	for member in squad:squad_members() do
		if member.id == id then
			return true
		end
	end
	return false
end

function is_player_fighting()
	return not is_empty(xr_combat_ignore.fighting_with_actor_npcs)
end

marked_enemies = {}
function mark_current_enemies()
	for _,id in pairs(marked_enemies) do
		level.map_remove_object_spot(id, "anomaly_thermal")
	end
	empty_table(marked_enemies)
	for id,_ in pairs(xr_combat_ignore.fighting_with_actor_npcs) do
		if not western_goods_utils.table_contains(marked_enemies, id) then
			table.insert(marked_enemies, id)
			level.map_add_object_spot_ser(id, "anomaly_thermal", "Enemy")
		end
	end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Test functions		TODO : Remove this section
-- ---------------------------------------------------------------------------------------------------------------------

function spawn_btr(x, y, z, lvid, gvid)
	local btr_se = alife_create("veh_btr", vector():set(x, y, z), lvid, gvid)

	logic_enforcer.assign(btr_se.id,'scripts\\tasks\\veh_idle.ltx','logic','ph_car@idle')

	dbg_printf("[WG] BTR spawned with id %s",btr_se.id)

	return btr_se
end

function spawn_dunn(dik)
	if dik ~= DIK_keys.DIK_L then return end

	local dunn = spawn_squad("stalker_dunn_lynn_squad", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
end

local stage = 0
function spawn_test_squads(dik)
	if dik ~= DIK_keys.DIK_P then return end

	dbg_printf("[WG] spawn_test_squads")

	dbg_printf("[WG] Fighting with player :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))
	dbg_printf("[WG] Fighting player : %s", not is_empty(xr_combat_ignore.fighting_with_actor_npcs))

end

--[[
if stage == 0 then
    local smart = SIMBOARD.smarts_by_names["pri_sim_3"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_zombie_1_squad")

    RegisterScriptCallback("actor_on_update",function ()
        local zombie_1_squad_se = se_object_by_sid("western_goods_act_2_task_2_zombie_1_squad")

        local dist = zombie_1_squad_se and zombie_1_squad_se.position:distance_to(db.actor:position())
        dbg_printf("[WG] Dist to zombies %s", dist)
    end)

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 1 then
    local smart = SIMBOARD.smarts_by_names["pri_sim_3"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_zombie_2_squad")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 2 then
    local smart = SIMBOARD.smarts_by_names["pri_sim_3"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_army_squad")

    local btr_se = spawn_btr(-32.9, -0.5, 20.9, 155155, 4971)
    btr_se.angle = vector():set(0,-1.5708,0)

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 3 then
    local smart = SIMBOARD.smarts_by_names["pri_sim_3"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_mono_squad")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 4 then
    local smart = SIMBOARD.smarts_by_names["pri_b301"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_snork_squad")
    --local squad = spawn_squad("western_goods_act_2_task_2_snork_squad", vector():set(25.842678070068,-4.3245229721069,123.48170471191), 231878, 4970)
    --squad.scripted_target = "pri_b301"

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 5 then
    local smart = SIMBOARD.smarts_by_names["pri_b301"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_bandit_1_squad")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 6 then
    local smart = SIMBOARD.smarts_by_names["pri_a28_school"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_ecolog_squad")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 7 then
    local smart = SIMBOARD.smarts_by_names["pri_a28_school"]
    local squad = SIMBOARD:create_squad(smart,"western_goods_act_2_task_2_bandit_2_squad")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
if stage == 8 then
    surge_manager.start_surge()
    give_info("western_goods_act_2_task_2_ecolog_flee")

    dbg_printf("[WG] Test stage %s",stage)
    stage = stage + 1
    return
end
--]]
