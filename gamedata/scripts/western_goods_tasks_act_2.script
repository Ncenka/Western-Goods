---[[
--- Original Author(s) : NLTP_ASHES
--- Edited : N/A
--- Date : 03/03/2023
--- License : Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
---
--- Script used to manage the tasks of the Western Goods addon.
---]]

-- ---------------------------------------------------------------------------------------------------------------------
-- Constants, global variables and imported functions
-- ---------------------------------------------------------------------------------------------------------------------

-- Imported functions
local dbg_printf = western_goods_utils.dbg_printf
local get_translation = game.translate_string
local spawn_squad = western_goods_utils.spawn_squad
local send_dialog = western_goods_dialogs_manager.send_dialog

-- Task variables
TASK_1_CACHE = {}
TASK_2_CACHE = {}
TASK_3_CACHE = {}


-- ---------------------------------------------------------------------------------------------------------------------
-- ACT 2 - CONTRACT WORK
-- ---------------------------------------------------------------------------------------------------------------------
-- TASK 1 - KOLOBOK
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to start Act 2, Task 1.
--- @param first_speaker cse_alife_object
--- @param second_speaker cse_alife_object
--- @return nil
function start_task_1(first_speaker, second_speaker)
	local npc = dialogs.who_is_npc(first_speaker, second_speaker)
	task_manager.get_task_manager():give_task("western_goods_act_2_task_1", npc:id())
	dbg_printf("[WG] Act 2 Task 1 | Task started...")
end

--- Function used to end Act 2, Task 1.
--- @return nil
function end_task_1()
	local kolobok_found = false

	-- Items in player inventory that have a section among the ones in fallback_items
	local secondary_items_found = {}

	-- Iterate player inventory to find if he has kolobok, and gather fallback items in the process
	db.actor:iterate_inventory(function(owner, obj)
		local is_main_item = obj:section() == TASK_1_CACHE.main_item
		local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
		if is_main_item then
			kolobok_found = true
			return
		elseif is_secondary_item then
			table.insert(secondary_items_found, obj)
		end
	end)

	-- If the player doesn't have a Kolobok, use one of the fallback items
	if not kolobok_found then
		for _,obj in pairs(secondary_items_found) do
			itms_manager.use_arty_container(obj)
			break
		end
	end

	task_manager.get_task_manager():set_task_completed("western_goods_act_2_task_1")

	TASK_2_CACHE.available_time = time_global() + 1800000
	dbg_printf("[WG] Act 2 Task 1 | Task completed...")
end

--- Function called when the task is initiated.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_init(actor,npc)
	-- Prepare task cache table
	TASK_1_CACHE.main_item = "af_fuzz_kolobok"
	TASK_1_CACHE.secondary_items = {
		"af_fuzz_kolobok_lead_box",
		"af_fuzz_kolobok_af_aac",
		"af_fuzz_kolobok_af_aam",
		"af_fuzz_kolobok_af_iam"
	}

	-- Spawn task target if it doesn't exist in the world
	local main_item_exists = false

	western_goods_utils.server_objects_iter(function(se_obj)
		if se_obj:section_name() == TASK_1_CACHE.main_item then
			dbg_printf("[WG] Act 2 Task 1 | Main target already exist in the world %s", se_obj.id)
			main_item_exists = true
			return true
		end
	end)

	if not main_item_exists then
		dbg_printf("[WG] Act 2 Task 1 | Main target does not exist in the world...")

		local viable_spawn_anomalies = get_static_chemical_anomalies() or {}
		local spawn_anomaly_id = random_key_table(viable_spawn_anomalies)
		local spawn_anomaly = spawn_anomaly_id and alife_object(spawn_anomaly_id)

		if spawn_anomaly then
			alife_create(TASK_1_CACHE.main_item, spawn_anomaly.position, spawn_anomaly.m_level_vertex_id, spawn_anomaly.m_game_vertex_id)
			dbg_printf("[WG] Act 2 Task 2 | Spawned main target at pos:%s lvid:%s gvid:%s", spawn_anomaly.position, spawn_anomaly.m_level_vertex_id, spawn_anomaly.m_game_vertex_id)
		end
	end

	-- Process info portions
	give_info("western_goods_act_2_task_1_active")
	give_info("western_goods_act_2_task_1_init")
end

--- Function called when the task is successfully completed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_complete(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_1_active")
	disable_info("western_goods_act_2_task_1_init")
	give_info("western_goods_act_2_task_1_finished")

	-- Process quest items
	xr_effects.remove_item(actor, npc, {"af_fuzz_kolobok"})

	-- Process reward
	xr_effects.reward_random_money(actor,npc,{"10000","15000"})
	xr_effects.complete_task_inc_goodwill(actor,npc,{"25","killer"})
end

--- Function called when the task is failed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_1_fail(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_1_active")
	disable_info("western_goods_act_2_task_1_init")

	-- Process penalty
	xr_effects.fail_task_dec_goodwill(actor,npc,{"35","killer"})
end

--- Function used to retrieve the title of the mission (displayed in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_1_title_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_1_title")
	end
end

--- Function used to retrieve the description of the mission (displayed in the PDA).
--- Warning : naming contract on the translation string : st_wg_trader_act_2_task_1_stage_<stage>_descr.
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_1_descr_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_1_stage_" .. tostring(tsk.stage) .. "_descr")
	end
end

--- Function used to retrieve the target of the mission (marker displayed (or not) in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return number
function task_functor.act_2_task_1_target_f(task_id,field,p,tsk)
	if has_alife_info("western_goods_act_2_task_1_init") then
		if tsk.stage == 0 then
			return nil
		end
		if tsk.stage == 1 then
			return tsk.task_giver_id
		end
	end
end

--- Function used to manage the mission logic as a whole.
--- @param tsk CGameTask
--- @param task_id number
--- @return string
function task_status_functor.act_2_task_1_status_f(tsk,task_id)
	if has_alife_info("western_goods_act_2_task_1_init") then
		-- First stage : Find the artefact
		if tsk.stage == 0 then
			db.actor:iterate_inventory(function(owner, obj)
				local is_main_item = obj:section() == TASK_1_CACHE.main_item
				local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
				if is_main_item or is_secondary_item then
					tsk.stage = 1
					return
				end
			end)
		end

		-- Second stage : Deliver the artefact
		if tsk.stage == 1 then
			local has_item = false

			db.actor:iterate_inventory(function(owner, obj)
				local is_main_item = obj:section() == TASK_1_CACHE.main_item
				local is_secondary_item = western_goods_utils.table_contains(TASK_1_CACHE.secondary_items, obj:section())
				if is_main_item or is_secondary_item then
					has_item = true
					return
				end
			end)

			if not has_item then
				disable_info("western_goods_act_2_task_1_ready_finished")
				tsk.stage = 0
			else
				give_info("western_goods_act_2_task_1_ready_finished")
			end
		end
	end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- TASK 2 - RETRIEVAL MISSION
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to start Act 2, Task 2.
--- @param task_giver cse_alife_object
--- @return nil
function start_task_2(task_giver)
	task_manager.get_task_manager():give_task("western_goods_act_2_task_2", task_giver.id)
	dbg_printf("[WG] Act 2 Task 2 | Task started...")
end

--- Function used to end Act 2, Task 2.
--- @return nil
function end_task_2()
	task_manager.get_task_manager():set_task_completed("western_goods_act_2_task_2")
	dbg_printf("[WG] Act 2 Task 2 | Task completed...")
end

--- Function called when the task is initiated.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_init(actor,npc)
	TASK_2_CACHE = {
		main_item = "wg_act_2_task_2_quest_item",
		marked_enemies = {},
		objects = {
			btr 			= { sec="veh_btr",x=-32.9,y=-0.5,z=20.9,lvid=155155,gvid=4971 		},
			sleeping_bag 	= { sec="itm_sleepbag",x=26.6,y=-4.3,z=129.2,lvid=232806,gvid=4970 	}
		},
		squads = {
			army_spawn_data 		= { sec="western_goods_act_2_task_2_army_squad", 	 	smart="pri_sim_3" 							},
			mono_spawn_data 		= { sec="western_goods_act_2_task_2_mono_squad", 	 	smart="pri_sim_3" 							},
			snork_spawn_data 		= { sec="western_goods_act_2_task_2_snork_squad", 	 	smart="pri_b301" 							},
			ecolog_spawn_data 		= { sec="western_goods_act_2_task_2_ecolog_squad", 	 	smart="pri_a28_school",	smart2="pri_b303" 	},
			zombie_1_spawn_data 	= { sec="western_goods_act_2_task_2_zombie_1_squad", 	smart="pri_sim_3" 							},
			zombie_2_spawn_data 	= { sec="western_goods_act_2_task_2_zombie_2_squad", 	smart="pri_sim_3" 							},
			bandit_1_spawn_data 	= { sec="western_goods_act_2_task_2_bandit_1_squad", 	smart="pri_b301" 							},
			bandit_2_spawn_data 	= { sec="western_goods_act_2_task_2_bandit_2_squad", 	smart="pri_a28_school" 						},
			controller_spawn_data 	= { sec="western_goods_act_2_task_2_controller_squad", 	smart="pri_b303" 							},
			lynn_spawn_data 		= { sec="stalker_dunn_lynn_squad", 						smart="ds2_lager_st" 						},
			lynn_guards_spawn_data 	= { sec="western_goods_act_2_task_2_lynn_guards_squad", smart="ds2_lager_st" 						}
		},
		restrictors = {
			zombie 		= { ax=-97.150344848633,ay=-1.1752129793167,az=-45.473430633545,bx=-81.533813476563,by=5.2640190124512,	bz=-64.902114868164 },
			snork 		= { ax=17.24550819397,	ay=-4.823212146759,	az=129.98883056641,	bx=29.521947860718,	by=-1.0844190120697,bz=121.89762878418 	},
			overlook 	= { ax=27.744569778442,	ay=7.1062412261963,	az=129.99130249023,	bx=53.035232543945,	by=16.793748855591,	bz=121.89153289795 	},
			kbo         = { ax=3.7310662269592,	ay=4.2264876365662,	az=272.10140991211,	bx=14.69687461853,	by=8.0234889984131,	bz=265.22302246094	}
		}
	}

	-- Process info portions
	give_info("western_goods_act_2_task_2_active")
	give_info("western_goods_act_2_task_2_init")
end

--- Function called when the task is successfully completed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_complete(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_2_active")
	disable_info("western_goods_act_2_task_2_init")
	give_info("western_goods_act_2_task_2_finished")
	give_info("western_goods_act_2_finished")

	-- Process quest items
	xr_effects.remove_item(actor, npc, {"wg_act_2_task_2_quest_item"})

	-- Process reward
	xr_effects.reward_random_money(actor,npc,{"15000","20000"})
	xr_effects.complete_task_inc_goodwill(actor,npc,{"100","isg"})
	xr_effects.complete_task_inc_goodwill(actor,npc,{"25","killer"})
end

--- Function called when the task is failed.
--- @param actor cse_alife_object
--- @param npc cse_alife_object
--- @return nil
function xr_effects.western_goods_act_2_task_2_fail(actor,npc)
	-- Process info portions
	disable_info("western_goods_act_2_task_2_active")
	disable_info("western_goods_act_2_task_2_init")

	-- Process penalty
	xr_effects.fail_task_dec_goodwill(actor,npc,{"40","killer"})
end

--- Function used to retrieve the title of the mission (displayed in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_2_title_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_2_title")
	end
end

--- Function used to retrieve the description of the mission (displayed in the PDA).
--- Warning : naming contract on the translation string : st_wg_trader_act_2_task_2_stage_<stage>_descr.
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return string
function task_functor.act_2_task_2_descr_f(task_id,field,p,tsk)
	if true then -- Cond to force my IDE to fold this fucking function correctly
		return game.translate_string("st_wg_act_2_task_2_stage_" .. tostring(tsk.stage) .. "_descr")
	end
end

--- Function used to retrieve the target of the mission (marker displayed (or not) in the PDA).
--- @param task_id number
--- @param field string
--- @param p any
--- @param tsk CGameTask
--- @return number
function task_functor.act_2_task_2_target_f(task_id,field,p,tsk)
	if has_alife_info("western_goods_act_2_task_2_init") then
		if tsk.stage == 0 then
			local smart = SIMBOARD:get_smart_by_name("pri_sim_3")
			return smart and smart.id
		end
		if tsk.stage == 1 then
			local zombie_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)
			return zombie_1_squad_se and zombie_1_squad_se.id
		end
		if tsk.stage == 2 then
			local zombie_2_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)
			return zombie_2_squad_se and zombie_2_squad_se.id
		end
		if tsk.stage == 3 then
			-- Put a red marker over all the pursuers (only in pripyat, to avoid cheating)
			if level.name() == "pripyat" then
				mark_current_enemies(TASK_2_CACHE.marked_enemies)
			end

			-- Return nil as to not place an actual task marker
			return nil
		end
		if tsk.stage == 4 then
			-- Remove left-over markers (just in case)
			if level.name() == "pripyat" then
				mark_current_enemies(TASK_2_CACHE.marked_enemies)
			end

			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 5 then
			local snork_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return (snork_squad_se and snork_squad_se.id) or (restrictor and restrictor:id())
		end
		if tsk.stage == 6 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 7 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 8 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 9 then
			local smart = SIMBOARD:get_smart_by_name("pri_b301")
			return smart and smart.id
		end
		if tsk.stage == 10 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]
			return restrictor and restrictor:id()
		end
		if tsk.stage == 11 then
			local smart = SIMBOARD:get_smart_by_name("pri_b303")
			return smart and smart.id
		end
		if tsk.stage == 12 then
			local supplies_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.main_item)
			return supplies_se and supplies_se.id
		end
		if tsk.stage == 13 then
			local lynn_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.lynn_spawn_data.sec)
			return lynn_squad_se and lynn_squad_se.id
		end
	end
end

--- Function used to manage the mission logic as a whole.
--- @param tsk CGameTask
--- @param task_id number
--- @return string
function task_status_functor.act_2_task_2_status_f(tsk,task_id)
	if has_alife_info("western_goods_act_2_task_2_init") then

		-- Throughout the whole task : clear the two smarts so nothing interfere with the task
		task_2_clear_smart_terrain("pri_a28_school")
		task_2_clear_smart_terrain("pri_b301")
		task_2_clear_smart_terrain("pri_b303")

		-- First stage : Get to the Outskirts, somewhere close to the zombies
		if tsk.stage == 0 then
			local zombie_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)

			-- Spawn Zombie squad
			if not TASK_2_CACHE.zombie_1_spawned and not zombie_1_squad_se then
				local spawn_data = TASK_2_CACHE.squads.zombie_1_spawn_data
				zombie_1_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if zombie_1_squad_se then
					TASK_2_CACHE.zombie_1_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			if level.name() ~= "pripyat" then return end

			local dist_to_zombies = zombie_1_squad_se and zombie_1_squad_se.position:distance_to(db.actor:position())
			if dist_to_zombies and dist_to_zombies > 125 then return end

			dbg_printf("[WG] Act 2 Task 2 Stage 0 | Player close to Zombied squad %s", dist_to_zombies)

			tsk.stage = 1
		end

		-- Second stage : Kill the zombies and get close
		if tsk.stage == 1 then
			local zombie_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_1_spawn_data.sec)

			-- If the zombie squad is dead, and the player is near them
			if not zombie_1_squad_se and western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.zombie) then

				dbg_printf("[WG] Act 2 Task 2 Stage 1 | First Zombied squad is dead")

				local zombie_2_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)

				-- Spawn Zombie squad for next stage
				if not TASK_2_CACHE.zombie_2_spawned and not zombie_2_squad_se then
					local spawn_data = TASK_2_CACHE.squads.zombie_2_spawn_data
					zombie_2_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

					if zombie_2_squad_se then
						TASK_2_CACHE.spawn_throttle = time_global() + 5000
						TASK_2_CACHE.zombie_2_spawned = true
						return
					else
						printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
						return "fail"
					end
				end

				tsk.stage = 2
			end
		end

		-- Third stage : Wait for zombies to die or take part in the fight
		if tsk.stage == 2 then
			local zombie_2_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.zombie_2_spawn_data.sec)
			local army_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.army_spawn_data.sec)
			local mono_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.mono_spawn_data.sec)

			-- Spawn Army squad
			if TASK_2_CACHE.spawn_throttle < time_global() and not TASK_2_CACHE.army_squad_spawned and not army_squad_se then
				local spawn_data = TASK_2_CACHE.squads.army_spawn_data
				army_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if army_squad_se then
					TASK_2_CACHE.spawn_throttle = time_global() + 5000
					TASK_2_CACHE.army_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- Spawn Army BTR
			if TASK_2_CACHE.spawn_throttle < time_global() and not TASK_2_CACHE.army_btr_spawned then
				local spawn_data = TASK_2_CACHE.objects.btr
				local btr_se = alife_create(spawn_data.sec, vector():set(spawn_data.x, spawn_data.y, spawn_data.z), spawn_data.lvid, spawn_data.gvid)

				if btr_se then
					btr_se.angle = vector():set(0,-1.5708,0)

					logic_enforcer.assign(btr_se.id,'scripts\\tasks\\veh_idle.ltx','logic','ph_car@idle')

					TASK_2_CACHE.spawn_throttle = time_global() + 5000
					TASK_2_CACHE.army_btr_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s x:%s y:%s z:%s lvid:%s gvid:%s",spawn_data.sec, spawn_data.x, spawn_data.y, spawn_data.z, spawn_data.lvid, spawn_data.gvid)
					return "fail"
				end
			end

			-- When zombies are dead, progress task
			if TASK_2_CACHE.zombie_2_spawned and not zombie_2_squad_se then

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Second Zombied squad is dead")

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_stage_2_message_1")}
				})
				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Message from %s ready", "Anonymous")

				if is_player_fighting() then
					dbg_printf("[WG] Act 2 Task 2 Stage 2 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))
					tsk.stage = 3
				else
					dbg_printf("[WG] Act 2 Task 2 Stage 2 | Player is not fighting")
					tsk.stage = 4
				end
			end
		end

		-- Fourth stage : Get to the basement of the school but kill pursuers
		if tsk.stage == 3 then
			if is_player_fighting() then
				local restrictor = db.zone_by_name["pri_surge_hide_b301"]
				local dist_to_basement = restrictor and restrictor:position():distance_to(db.actor:position())

				dbg_printf("[WG] Act 2 Task 2 Stage 3 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))

				if dist_to_basement and dist_to_basement <= 50 and dist_to_basement >= 25 then
					if not TASK_2_CACHE.message_school_pursuers_far_sent then
						send_dialog({
							{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_school_pursuers_far")}
						},true)
						TASK_2_CACHE.message_school_pursuers_far_sent = true
					end
					return
				elseif dist_to_basement and dist_to_basement < 25 then
					send_dialog({
						{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_school_pursuers_close")}
					},true)
					return "fail"
				else
					TASK_2_CACHE.message_school_pursuers_far_sent = false
					return
				end
			else
				dbg_printf("[WG] Act 2 Task 2 Stage 3 | Player is not fighting")
				TASK_2_CACHE.message_school_pursuers_far_sent = false
				tsk.stage = 4
			end
		end

		-- Fifth stage : Get to the basement of the school without being seen
		if tsk.stage == 4 then
			local restrictor = db.zone_by_name["pri_surge_hide_b301"]

			if not is_player_fighting() then
				local dist_to_basement = restrictor and restrictor:position():distance_to(db.actor:position())
				if dist_to_basement and dist_to_basement < 25 then
					local snork_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)

					-- Spawn snork squad
					if not TASK_2_CACHE.snork_spawned and not snork_squad_se then
						local spawn_data = TASK_2_CACHE.squads.snork_spawn_data
						snork_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

						if snork_squad_se then
							TASK_2_CACHE.snork_spawned = true
							tsk.stage = 5
							return
						else
							printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
							return "fail"
						end
					end
				end
			else
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Player is fighting :\n%s", utils_data.print_table(xr_combat_ignore.fighting_with_actor_npcs, false, true))
				tsk.stage = 3
			end
		end

		-- Sixth stage : Get to the basement of the school & kill the snorks
		if tsk.stage == 5 then
			local snork_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.snork_spawn_data.sec)

			-- Dialog when player reaches school
			if not TASK_2_CACHE.stage_5_dialog_sent then

				local dialog_sender_1 = { name=alife():actor():character_name(), icon=alife():actor():character_icon()}
				local dialog_sender_2 = { name="Anonymous", icon="ui_inGame2_no_data"}

				dbg_printf("[WG] Act 2 Task 2 Stage 5 | Preparing dialog between %s and %s", dialog_sender_1.name, dialog_sender_2.name)
				send_dialog({
					{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_5_message_1")},
					{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_5_message_2")}
				})
				dbg_printf("[WG] Act 2 Task 2 Stage 5 | Dialog between %s and %s ready", dialog_sender_1.name, dialog_sender_2.name)

				TASK_2_CACHE.stage_5_dialog_sent = true
			end

			-- Spawn sleeping bag
			if not TASK_2_CACHE.sleeping_bag_spawned then
				local spawn_data = TASK_2_CACHE.objects.sleeping_bag
				local sleep_bag_se = alife_create(spawn_data.sec, vector():set(spawn_data.x, spawn_data.y, spawn_data.z), spawn_data.lvid, spawn_data.gvid)

				if sleep_bag_se then
					TASK_2_CACHE.sleeping_bag_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s x:%s y:%s z:%s lvid:%s gvid:%s",spawn_data.sec, spawn_data.x, spawn_data.y, spawn_data.z, spawn_data.lvid, spawn_data.gvid)
					return "fail"
				end
			end

			-- If the zombie squad is dead, and the player is near them
			if TASK_2_CACHE.snork_spawned and not snork_squad_se and western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.snork) then

				dbg_printf("[WG] Act 2 Task 2 Stage 2 | Snork squad is dead")

				local bandit_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)

				-- Spawn bandit squad for next stage
				if not TASK_2_CACHE.bandit_1_spawned and not bandit_1_squad_se then
					local spawn_data = TASK_2_CACHE.squads.bandit_1_spawn_data
					bandit_1_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

					if bandit_1_squad_se then
						TASK_2_CACHE.bandit_1_spawned = true
						return
					else
						printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
						return "fail"
					end
				end

				tsk.stage = 6
			end
		end

		-- Seventh stage : Kill the bandits
		if tsk.stage == 6 then
			local bandit_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)

			-- Fail task if player gets out of basement
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.snork) then
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 4 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- If bandits are dead, or if they are not enemy with the player
			if TASK_2_CACHE.bandit_1_spawned and not bandit_1_squad_se then

				if not TASK_2_CACHE.stage_6_dialog_sent then

					dbg_printf("[WG] Act 2 Task 2 Stage 6 | First bandit squad is dead")

					local dialog_sender_1 = { name="Anonymous", icon="ui_inGame2_no_data"}
					local dialog_sender_2 = { name=alife():actor():character_name(), icon=alife():actor():character_icon()}

					dbg_printf("[WG] Act 2 Task 2 Stage 6 | Preparing dialog between %s and %s", dialog_sender_1.name, dialog_sender_2.name)
					send_dialog({
						{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_1")},
						{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_2")},
						{sender=dialog_sender_1.name, icon=dialog_sender_1.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_3")},
						{sender=dialog_sender_2.name, icon=dialog_sender_2.icon, message=get_translation("st_wg_trader_act_2_task_2_stage_6_message_4")}
					})
					dbg_printf("[WG] Act 2 Task 2 Stage 6 | Dialog between %s and %s ready", dialog_sender_1.name, dialog_sender_2.name)

					TASK_2_CACHE.progress_timer = time_global() + 30000
					TASK_2_CACHE.stage_6_dialog_sent = true
				end

				if TASK_2_CACHE.progress_timer < time_global() then
					tsk.stage = 7
				end
			end
		end

		-- Eighth stage : Get to the 3rd floor of the school
		if tsk.stage == 7 then
			-- When the player gets in position, progress task
			if western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				tsk.stage = 8
				return
			end
		end

		-- Ninth stage : Wait for ecologs to arrive
		if tsk.stage == 8 then
			local ecolog_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.ecolog_spawn_data.sec)

			-- Spawn Ecolog squad
			if not TASK_2_CACHE.ecolog_spawned and not ecolog_squad_se then
				local spawn_data = TASK_2_CACHE.squads.ecolog_spawn_data
				ecolog_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if ecolog_squad_se then
					TASK_2_CACHE.progress_timer = time_global() + 60000
					TASK_2_CACHE.ecolog_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- If player leaves his position, fail task
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				dbg_printf("[WG] Act 2 Task 2 Stage 8 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 8 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- After 45s, progress task
			if TASK_2_CACHE.progress_timer < time_global() then
				tsk.stage = 9
			end
		end

		-- Tenth stage : Wait for the bandits to die
		if tsk.stage == 9 then
			local bandit_1_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.bandit_1_spawn_data.sec)
			local bandit_2_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.bandit_2_spawn_data.sec)

			-- Spawn Bandit squad
			if not TASK_2_CACHE.bandit_2_squad_spawned and not bandit_2_squad_se then
				local spawn_data = TASK_2_CACHE.squads.bandit_2_spawn_data
				bandit_2_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if bandit_2_squad_se then
					TASK_2_CACHE.bandit_2_autokill_timer = time_global() + 40000
					TASK_2_CACHE.bandit_2_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- If player leaves his position, fail task
			if not western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.overlook) then
				dbg_printf("[WG] Act 2 Task 2 Stage 7 | Preparing message from %s", "Anonymous")
				send_dialog({
					{sender="Anonymous", icon="ui_inGame2_no_data", message=get_translation("st_wg_trader_act_2_task_2_message_left_position")}
				},true)
				dbg_printf("[WG] Act 2 Task 2 Stage 7 | Message from %s ready", "Anonymous")
				return "fail"
			end

			-- After 20s, start killing the bandits (both bandit_1 and bandit_2 squads) automatically
			if not TASK_2_CACHE.bandit_2_autokilled and TASK_2_CACHE.bandit_2_autokill_timer < time_global() then
				if bandit_1_squad_se then
					for npc in bandit_1_squad_se:squad_members() do
						local npc_obj = db.storage[npc.id] and db.storage[npc.id].object
						if (npc_obj and npc_obj:alive()) then
							western_goods_utils.next_tick(surge_manager.make_dead,npc_obj:id())
						end
					end
				end
				if bandit_2_squad_se then
					for npc in bandit_2_squad_se:squad_members() do
						local npc_obj = db.storage[npc.id] and db.storage[npc.id].object
						if (npc_obj and npc_obj:alive()) then
							western_goods_utils.next_tick(surge_manager.make_dead,npc_obj:id())
						end
					end
				end
				TASK_2_CACHE.progress_timer = time_global() + 20000
				TASK_2_CACHE.bandit_2_autokilled = true
			end

			-- When all bandits are dead, progress task
			if not bandit_1_squad_se and not bandit_2_squad_se and TASK_2_CACHE.progress_timer < time_global() then
				tsk.stage = 10
			end
		end

		-- Eleventh stage : Take cover from the emission
		if tsk.stage == 10 then
			local ecolog_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.ecolog_spawn_data.sec)

			-- Start emission and make ecologs flee
			if not TASK_2_CACHE.surge_started then
				surge_manager.start_surge()

				-- Give info to link script with logic scheme
				give_info("western_goods_act_2_task_2_ecolog_flee")
				TASK_2_CACHE.ecolog_teleport_timer = time_global() + 50000

				TASK_2_CACHE.surge_started = true
			end

			if not TASK_2_CACHE.ecolog_teleported and TASK_2_CACHE.ecolog_teleport_timer < time_global() and ecolog_squad_se then
				-- Release 'old' squad
				SIMBOARD:remove_squad(ecolog_squad_se)

				-- Create 'new' squad at new location
				local spawn_data = TASK_2_CACHE.squads.ecolog_spawn_data
				ecolog_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart2)

				TASK_2_CACHE.ecolog_teleported = true
			end

			if TASK_2_CACHE.surge_started and surge_manager.is_finished() then
				if ecolog_squad_se then
					for member in ecolog_squad_se:squad_members() do
						if alife_object(member.id):section_name() ~= "stalker_ecolog_convoy_yellow" then
							CreateTimeEvent("western_goods_delay_kill_squad",member.id,0,surge_manager.make_dead,member.id)
						end
					end
				end
				tsk.stage = 11
			end
		end

		-- Twelfth stage : Get to the yellow crewmate & kill the controller
		if tsk.stage == 11 then
			local controller_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.controller_spawn_data.sec)
			local supplies_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.main_item)

			-- Calm ecolog when player enters room
			if western_goods_restrictors.in_bounds(db.actor, TASK_2_CACHE.restrictors.kbo) then
				give_info("western_goods_act_2_task_2_ecolog_calm")
			end

			-- Wait for player to finish dialog with crewmate
			if not has_alife_info("western_goods_ecolog_convoy_yellow_meet_over") then return end

			-- Spawn Controller squad
			if not TASK_2_CACHE.controller_squad_spawned and not controller_squad_se then
				local spawn_data = TASK_2_CACHE.squads.controller_spawn_data
				controller_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if controller_squad_se then
					give_info("western_goods_act_2_task_2_controller_spawned")
					TASK_2_CACHE.controller_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- When controller is dead, send signal to logic scheme
			if TASK_2_CACHE.controller_squad_spawned and not controller_squad_se then
				give_info("western_goods_act_2_task_2_controller_killed")
			end

			-- Wait for player to finish second dialog
			if not has_alife_info("western_goods_ecolog_convoy_yellow_second_meet_over") then return end

			local lynn_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.lynn_spawn_data.sec)
			local lynn_guards_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.lynn_guards_spawn_data.sec)

			-- Spawn Dunn Lynn squad
			if not TASK_2_CACHE.lynn_squad_spawned and not lynn_squad_se then
				local spawn_data = TASK_2_CACHE.squads.lynn_spawn_data
				lynn_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if lynn_squad_se then
					TASK_2_CACHE.lynn_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			-- Spawn Dunn Lynn guards squad
			if not TASK_2_CACHE.lynn_guards_squad_spawned and not lynn_guards_squad_se then
				local spawn_data = TASK_2_CACHE.squads.lynn_guards_spawn_data
				lynn_guards_squad_se = western_goods_utils.spawn_squad_smart(spawn_data.sec, spawn_data.smart)

				if lynn_guards_squad_se then
					TASK_2_CACHE.lynn_guards_squad_spawned = true
					return
				else
					printe("!ERROR failed to spawn %s smart:%s",spawn_data.sec, spawn_data.smart)
					return "fail"
				end
			end

			if not (supplies_se and (supplies_se.parent_id ~= AC_ID)) then
				tsk.stage = 13
			else
				tsk.stage = 12
			end
		end

		-- Thirteenth stage : Get the case
		if tsk.stage == 12 then
			local supplies_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.main_item)

			-- If the supplies cannot be found, respawn them
			if not supplies_se then
				-- Spawn the supplies, objective the player has to retrieve
				supplies_se = alife_create(TASK_2_CACHE.main_item, vector():set(4.8,4.6,269.3), 204172, 4926)
				dbg_printf("[WG] Act 2 Task 2 Stage 12 | Quest item respawned %s", supplies_se.id)

				return
			end

			-- If the player picked up the supplies, progress to stage 3
			if not (supplies_se and (supplies_se.parent_id ~= AC_ID)) then
				dbg_printf("[WG] Act 2 Task 2 Stage 12 | Player picked up the supplies %s", supplies_se.id)
				tsk.stage = 13
				return
			end
		end

		-- Thirteenth stage : Return the case
		if tsk.stage == 13 then
			local supplies_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.main_item)

			-- If the supplies cannot be found (which is odd), roll back to stage 12
			if not supplies_se then
				dbg_printf("[WG] Act 1 Task 1 Stage 3 | Supplies disappeared, rolling back to stage 2...")
				tsk.stage = 12
				return
			end

			give_info("western_goods_act_2_task_2_ready_finished")

			-- If the player dropped the supplies, rollback to stage 2
			if supplies_se and (supplies_se.parent_id ~= AC_ID) then
				dbg_printf("[WG] Act 2 Task 2 Stage 13 | Player dropped the supplies %s", supplies_se.id)

				disable_info("western_goods_act_2_task_2_ready_finished")

				tsk.stage = 12
				return
			end
		end
	end
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Callbacks registration
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to register callbacks.
--- @return nil
function on_game_start()
	RegisterScriptCallback("save_state", save_state)
	RegisterScriptCallback("load_state", load_state)
	RegisterScriptCallback("actor_on_first_update", setup_act_2_task_2)
	RegisterScriptCallback("actor_on_first_update", remove_dunn_lynn_after_task)
end


-- ---------------------------------------------------------------------------------------------------------------------
-- Data persistence
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to store information in the save file.
--- @param m_data table
--- @return nil
function save_state(m_data)
	-- Prepare save tables
	local TASK_1_SAVE = {}
	local TASK_2_SAVE = {}
	local TASK_3_SAVE = {}

	-- Make copies of task caches
	copy_table(TASK_1_SAVE, TASK_1_CACHE)
	copy_table(TASK_2_SAVE, TASK_2_CACHE)
	copy_table(TASK_3_SAVE, TASK_3_CACHE)

	-- Pre-process tables
	TASK_2_SAVE.available_time = (TASK_2_SAVE.available_time or 0) - time_global()
	TASK_2_SAVE.spawn_throttle = (TASK_2_SAVE.spawn_throttle or 0) - time_global()
	TASK_2_SAVE.progress_timer = (TASK_2_SAVE.progress_timer or 0) - time_global()
	TASK_2_SAVE.bandit_2_autokill_timer = (TASK_2_SAVE.bandit_2_autokill_timer or 0) - time_global()

	-- Debug prints
	dbg_printf("[WG] TASK_2_CACHE.available_time : %s", TASK_2_SAVE.available_time)
	dbg_printf("[WG] TASK_2_CACHE.spawn_throttle : %s", TASK_2_SAVE.spawn_throttle)
	dbg_printf("[WG] TASK_2_CACHE.progress_timer : %s", TASK_2_SAVE.progress_timer)
	dbg_printf("[WG] TASK_2_CACHE.bandit_2_autokill_timer : %s", TASK_2_SAVE.bandit_2_autokill_timer)

	-- Save tables
	m_data.wg_act_2_task_1_cache = TASK_1_SAVE
	m_data.wg_act_2_task_2_cache = TASK_2_SAVE
	m_data.wg_act_2_task_3_cache = TASK_3_SAVE

	dbg_printf("[WG] Saved act 2 task variables")

	-- Save utility function metatables
	m_data.marked_enemies = marked_enemies
end

--- Function used to load information stored in the save file.
--- @param m_data table
--- @return nil
function load_state(m_data)
	-- Retrieve save tables
	local TASK_1_SAVE = m_data.wg_act_2_task_1_cache or {}
	local TASK_2_SAVE = m_data.wg_act_2_task_2_cache or {}
	local TASK_3_SAVE = m_data.wg_act_2_task_3_cache or {}

	-- Post-process tables
	TASK_2_SAVE.available_time = (TASK_2_SAVE.available_time or 0) + time_global()
	TASK_2_SAVE.spawn_throttle = (TASK_2_SAVE.spawn_throttle or 0) + time_global()
	TASK_2_SAVE.progress_timer = (TASK_2_SAVE.progress_timer or 0) + time_global()
	TASK_2_SAVE.bandit_2_autokill_timer = (TASK_2_SAVE.bandit_2_autokill_timer or 0) + time_global()

	-- Debug prints
	dbg_printf("[WG] TASK_2_CACHE.available_time : %s", TASK_2_SAVE.available_time)
	dbg_printf("[WG] TASK_2_CACHE.spawn_throttle : %s", TASK_2_SAVE.spawn_throttle)
	dbg_printf("[WG] TASK_2_CACHE.progress_timer : %s", TASK_2_SAVE.progress_timer)
	dbg_printf("[WG] TASK_2_CACHE.bandit_2_autokill_timer : %s", TASK_2_SAVE.bandit_2_autokill_timer)

	-- Restore task caches
	copy_table(TASK_1_CACHE, TASK_1_SAVE)
	copy_table(TASK_2_CACHE, TASK_2_SAVE)
	copy_table(TASK_3_CACHE, TASK_3_SAVE)

	dbg_printf("[WG] Loaded act 2 task variables")

	-- Load utility function metatables
	marked_enemies = m_data.marked_enemies or {}
end


-- ---------------------------------------------------------------------------------------------------------------------
-- General functions
-- ---------------------------------------------------------------------------------------------------------------------

--- Function used to setup the automatic start of Act 2, Task 2.
--- @return nil
function setup_act_2_task_2()
	-- Conditions
	local task_1_done = has_alife_info("western_goods_act_2_task_1_finished")
	local task_2_started = has_alife_info("western_goods_act_2_task_2_active")
	local task_2_done = has_alife_info("western_goods_act_2_task_2_finished")
	local task_opted_in = has_alife_info("western_goods_act_2_task_2_opted_in")
	local task_setup = has_alife_info("western_goods_act_2_task_2_setup")
	local timeout_ready = time_global() > (TASK_2_CACHE.available_time or 0)

	-- If the task is ready to be started
	if task_1_done and not task_2_started and not task_2_done and task_opted_in and not task_setup and timeout_ready then
		CreateTimeEvent("western_goods_setup_task", "act_2_task_2", math.random(600, 1800), function ()
			dbg_printf("[WG] Act 2 Task 2 | Task available...")

			-- Give the task some time after loading the save
			start_task_2(western_goods_utils.se_object_by_sid("stalker_western_goods_trader"))

			-- Send a message to the player
			dbg_printf("[WG] Act 2 Task 2 | Preparing message from %s", "Anonymous")
			send_dialog({
				{sender="Anonymous", icon="ui_inGame2_no_data", message=game.translate_string("st_wg_act_2_task_2_job_descr")}
			}, true)
			dbg_printf("[WG] Act 2 Task 2 | Message from %s ready", "Anonymous")

			give_info("western_goods_act_2_task_2_setup")

			return true
		end)
	else
		dbg_printf("[WG] What's missing? task_opted_in:%s task_not_setup:%s timeout_ready:%s (%s/%s)", task_opted_in, not task_setup, timeout_ready, time_global(), TASK_2_CACHE.available_time)
	end
end

--- Function used to get a table where keys are IDs of chemical anomalies and values are boolean true.
--- @return table
function get_static_chemical_anomalies()

	local viable_anomalies = {}

	-- Set to false all dynamic anomalies
	for _,v in pairs(bind_anomaly_field.dyn_anomalies) do
		for id, _ in pairs(v) do
			viable_anomalies[id] = false
		end
	end

	-- Go through all IDs
	western_goods_utils.server_objects_iter(function(se_obj)
		if IsAnomaly(se_obj) then
			if viable_anomalies[se_obj.id] == nil then
				-- If the ID is unknown, then check for correct type of anomalies
				if string.find(se_obj:section_name(), "chemical") or string.find(se_obj:section_name(), "acidic") then
					viable_anomalies[se_obj.id] = true
				end
			else
				-- If the ID isn't nil, then it's a dynamic anomaly, we set to nil
				viable_anomalies[se_obj.id] = nil
			end
		end
	end)

	dbg_printf("[WG] Number of matching anomalies : %s", size_table(viable_anomalies))

	return viable_anomalies
end

function is_id_from_squad(squad,id)
	if not squad then return end

	for member in squad:squad_members() do
		if member.id == id then
			return true
		end
	end
	return false
end

function is_player_fighting()
	return not is_empty(xr_combat_ignore.fighting_with_actor_npcs)
end

function mark_current_enemies(marked_enemies)
	for _,id in pairs(marked_enemies) do
		level.map_remove_object_spot(id, "anomaly_thermal")
	end
	empty_table(marked_enemies)
	for id,_ in pairs(xr_combat_ignore.fighting_with_actor_npcs) do
		if not western_goods_utils.table_contains(marked_enemies, id) then
			table.insert(marked_enemies, id)
			level.map_add_object_spot_ser(id, "anomaly_thermal", "Enemy")
		end
	end
end

function give_task_2_quest_item(first_speaker, second_speaker)
	dialogs.relocate_item_section_to_actor(first_speaker, second_speaker, "wg_act_2_task_2_quest_item")
end

function remove_dunn_lynn_after_task()
	if has_alife_info("western_goods_act_2_task_2_finished") and not (TASK_2_CACHE.lynn_squad_removed and TASK_2_CACHE.lynn_guards_squad_removed) then
		local lynn_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.lynn_spawn_data.sec)
		local lynn_guards_squad_se = western_goods_utils.se_object_by_sid(TASK_2_CACHE.squads.lynn_guards_spawn_data.sec)

		dbg_printf("[WG] Act 2 Task 2 | Trying to remove Lynn and/or his guards")

		-- Remove Dunn Lynn squad if it wasn't removed yet
		if not TASK_2_CACHE.lynn_squad_removed and lynn_squad_se and not simulation_objects.is_on_the_same_level(alife():actor(), lynn_squad_se) then
			SIMBOARD:remove_squad(lynn_squad_se)
			dbg_printf("[WG] Act 2 Task 2 | Removed Dunn Lynn squad %s", lynn_squad_se.id)
		end
		-- Remove Dunn Lynn guards squad if it wasn't removed yet
		if not TASK_2_CACHE.lynn_guards_squad_removed and lynn_guards_squad_se and not simulation_objects.is_on_the_same_level(alife():actor(), lynn_guards_squad_se)then
			SIMBOARD:remove_squad(lynn_guards_squad_se)
			dbg_printf("[WG] Act 2 Task 2 | Removed Dunn Lynn guards squad %s", lynn_guards_squad_se.id)
		end
	end
end

function task_2_clear_smart_terrain(smart_name)
	local smart_clear = SIMBOARD:get_smart_by_name(smart_name)
	for id,bool in pairs(SIMBOARD.smarts[smart_clear.id].squads) do
		local can_stay = false
		local squad = alife_object(id)
		if squad then
			for _,spawn_data in pairs(TASK_2_CACHE.squads) do
				if squad:section_name() == spawn_data.sec then
					can_stay = true
				end
			end
			local is_another_map = not simulation_objects.is_on_the_same_level(alife():actor(), squad)
			local distance = western_goods_utils.get_distance_sqr(alife():actor().position,squad.position)
			if not can_stay and (is_another_map or distance > 2500) then
				SIMBOARD:remove_squad(squad)
				dbg_printf("[WG] Act 2 Task 2 | Released random squad '%s' from smart '%s' (dist(sqr):%s)",squad:name(),smart_clear:name(),distance)
			end
		end
	end
end